(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_a664815c._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    }, specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, Error("react-stack-top-frame"), createTask(getTaskName(type)));
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/perfect-freehand/dist/esm/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>_e),
    "getStroke": (()=>ae),
    "getStrokeOutlinePoints": (()=>ce),
    "getStrokePoints": (()=>me)
});
function $(e, t, u, x = (h)=>h) {
    return e * x(.5 - t * (.5 - u));
}
function se(e) {
    return [
        -e[0],
        -e[1]
    ];
}
function l(e, t) {
    return [
        e[0] + t[0],
        e[1] + t[1]
    ];
}
function a(e, t) {
    return [
        e[0] - t[0],
        e[1] - t[1]
    ];
}
function b(e, t) {
    return [
        e[0] * t,
        e[1] * t
    ];
}
function he(e, t) {
    return [
        e[0] / t,
        e[1] / t
    ];
}
function R(e) {
    return [
        e[1],
        -e[0]
    ];
}
function B(e, t) {
    return e[0] * t[0] + e[1] * t[1];
}
function ue(e, t) {
    return e[0] === t[0] && e[1] === t[1];
}
function ge(e) {
    return Math.hypot(e[0], e[1]);
}
function de(e) {
    return e[0] * e[0] + e[1] * e[1];
}
function A(e, t) {
    return de(a(e, t));
}
function G(e) {
    return he(e, ge(e));
}
function ie(e, t) {
    return Math.hypot(e[1] - t[1], e[0] - t[0]);
}
function L(e, t, u) {
    let x = Math.sin(u), h = Math.cos(u), y = e[0] - t[0], n = e[1] - t[1], f = y * h - n * x, d = y * x + n * h;
    return [
        f + t[0],
        d + t[1]
    ];
}
function K(e, t, u) {
    return l(e, b(a(t, e), u));
}
function ee(e, t, u) {
    return l(e, b(t, u));
}
var { min: C, PI: xe } = Math, pe = .275, V = xe + 1e-4;
function ce(e, t = {}) {
    let { size: u = 16, smoothing: x = .5, thinning: h = .5, simulatePressure: y = !0, easing: n = (r)=>r, start: f = {}, end: d = {}, last: D = !1 } = t, { cap: S = !0, easing: j = (r)=>r * (2 - r) } = f, { cap: q = !0, easing: c = (r)=>--r * r * r + 1 } = d;
    if (e.length === 0 || u <= 0) return [];
    let p = e[e.length - 1].runningLength, g = f.taper === !1 ? 0 : f.taper === !0 ? Math.max(u, p) : f.taper, T = d.taper === !1 ? 0 : d.taper === !0 ? Math.max(u, p) : d.taper, te = Math.pow(u * x, 2), _ = [], M = [], H = e.slice(0, 10).reduce((r, i)=>{
        let o = i.pressure;
        if (y) {
            let s = C(1, i.distance / u), W = C(1, 1 - s);
            o = C(1, r + (W - r) * (s * pe));
        }
        return (r + o) / 2;
    }, e[0].pressure), m = $(u, h, e[e.length - 1].pressure, n), U, X = e[0].vector, z = e[0].point, F = z, O = z, E = F, J = !1;
    for(let r = 0; r < e.length; r++){
        let { pressure: i } = e[r], { point: o, vector: s, distance: W, runningLength: I } = e[r];
        if (r < e.length - 1 && p - I < 3) continue;
        if (h) {
            if (y) {
                let v = C(1, W / u), Z = C(1, 1 - v);
                i = C(1, H + (Z - H) * (v * pe));
            }
            m = $(u, h, i, n);
        } else m = u / 2;
        U === void 0 && (U = m);
        let le = I < g ? j(I / g) : 1, fe = p - I < T ? c((p - I) / T) : 1;
        m = Math.max(.01, m * Math.min(le, fe));
        let re = (r < e.length - 1 ? e[r + 1] : e[r]).vector, Y = r < e.length - 1 ? B(s, re) : 1, be = B(s, X) < 0 && !J, ne = Y !== null && Y < 0;
        if (be || ne) {
            let v = b(R(X), m);
            for(let Z = 1 / 13, w = 0; w <= 1; w += Z)O = L(a(o, v), o, V * w), _.push(O), E = L(l(o, v), o, V * -w), M.push(E);
            z = O, F = E, ne && (J = !0);
            continue;
        }
        if (J = !1, r === e.length - 1) {
            let v = b(R(s), m);
            _.push(a(o, v)), M.push(l(o, v));
            continue;
        }
        let oe = b(R(K(re, s, Y)), m);
        O = a(o, oe), (r <= 1 || A(z, O) > te) && (_.push(O), z = O), E = l(o, oe), (r <= 1 || A(F, E) > te) && (M.push(E), F = E), H = i, X = s;
    }
    let P = e[0].point.slice(0, 2), k = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : l(e[0].point, [
        1,
        1
    ]), Q = [], N = [];
    if (e.length === 1) {
        if (!(g || T) || D) {
            let r = ee(P, G(R(a(P, k))), -(U || m)), i = [];
            for(let o = 1 / 13, s = o; s <= 1; s += o)i.push(L(r, P, V * 2 * s));
            return i;
        }
    } else {
        if (!(g || T && e.length === 1)) if (S) for(let i = 1 / 13, o = i; o <= 1; o += i){
            let s = L(M[0], P, V * o);
            Q.push(s);
        }
        else {
            let i = a(_[0], M[0]), o = b(i, .5), s = b(i, .51);
            Q.push(a(P, o), a(P, s), l(P, s), l(P, o));
        }
        let r = R(se(e[e.length - 1].vector));
        if (T || g && e.length === 1) N.push(k);
        else if (q) {
            let i = ee(k, r, m);
            for(let o = 1 / 29, s = o; s < 1; s += o)N.push(L(i, k, V * 3 * s));
        } else N.push(l(k, b(r, m)), l(k, b(r, m * .99)), a(k, b(r, m * .99)), a(k, b(r, m)));
    }
    return _.concat(N, M.reverse(), Q);
}
function me(e, t = {}) {
    var q;
    let { streamline: u = .5, size: x = 16, last: h = !1 } = t;
    if (e.length === 0) return [];
    let y = .15 + (1 - u) * .85, n = Array.isArray(e[0]) ? e : e.map(({ x: c, y: p, pressure: g = .5 })=>[
            c,
            p,
            g
        ]);
    if (n.length === 2) {
        let c = n[1];
        n = n.slice(0, -1);
        for(let p = 1; p < 5; p++)n.push(K(n[0], c, p / 4));
    }
    n.length === 1 && (n = [
        ...n,
        [
            ...l(n[0], [
                1,
                1
            ]),
            ...n[0].slice(2)
        ]
    ]);
    let f = [
        {
            point: [
                n[0][0],
                n[0][1]
            ],
            pressure: n[0][2] >= 0 ? n[0][2] : .25,
            vector: [
                1,
                1
            ],
            distance: 0,
            runningLength: 0
        }
    ], d = !1, D = 0, S = f[0], j = n.length - 1;
    for(let c = 1; c < n.length; c++){
        let p = h && c === j ? n[c].slice(0, 2) : K(S.point, n[c], y);
        if (ue(S.point, p)) continue;
        let g = ie(p, S.point);
        if (D += g, c < j && !d) {
            if (D < x) continue;
            d = !0;
        }
        S = {
            point: p,
            pressure: n[c][2] >= 0 ? n[c][2] : .5,
            vector: G(a(S.point, p)),
            distance: g,
            runningLength: D
        }, f.push(S);
    }
    return f[0].vector = ((q = f[1]) == null ? void 0 : q.vector) || [
        0,
        0
    ], f;
}
function ae(e, t = {}) {
    return ce(me(e, t), t);
}
var _e = ae;
;
}}),
"[project]/node_modules/nanoid/url-alphabet/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "urlAlphabet": (()=>urlAlphabet)
});
const urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
}}),
"[project]/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @ts-self-types="./index.d.ts" */ __turbopack_context__.s({
    "customAlphabet": (()=>customAlphabet),
    "customRandom": (()=>customRandom),
    "nanoid": (()=>nanoid),
    "random": (()=>random)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$url$2d$alphabet$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/nanoid/url-alphabet/index.js [app-client] (ecmascript)");
;
;
let random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, defaultSize, getRandom)=>{
    let mask = (2 << Math.log2(alphabet.length - 1)) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize)=>{
        let id = '';
        while(true){
            let bytes = getRandom(step);
            let j = step | 0;
            while(j--){
                id += alphabet[bytes[j] & mask] || '';
                if (id.length >= size) return id;
            }
        }
    };
};
let customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size | 0, random);
let nanoid = (size = 21)=>{
    let id = '';
    let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
    while(size--){
        id += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$url$2d$alphabet$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["urlAlphabet"][bytes[size] & 63];
    }
    return id;
};
}}),
}]);

//# sourceMappingURL=node_modules_a664815c._.js.map